[![Ubuntu build][ubuntu-build-badge]][gh-actions]
[![codecov][codecov-badge]][codecov] &nbsp;
[![license][license-badge]][license]

# Spine Validation

The library brings data validation directly into your Protobuf messages.

### Why

Protobuf messages are defined using a language that lacks built-in mechanisms for enforcing 
domain-specific rules at run-time. As a result, developers must manually insert validation logic
or make explicit calls to a separate API to ensure message integrity, which can be error-prone 
and scattered across codebases of different languages.

### How

Spine Validation solves this by modifying the code generated by the Protobuf compiler (`protoc`).
At build time, the library injects assertions directly into the generated classes, enabling 
automatic enforcement of constraints without requiring explicit API calls in application code.

## Table of Contents

- [Prerequisites](#prerequisites)
- [Validation in Action](#validation-in-action)
- [Architecture](#architecture)
- [Extending the Library](#extending-the-library)

## Prerequisites

This library is built with Java 17.

## Validation in Action

Define your validation rules right in the .proto file:

```protobuf
import "spine/options.proto";
import "spine/time_options.proto";

import "google/protobuf/timestamp.proto";

message CardNumber {
    string digits = 1 [(pattern).regex = "\\d{4}\\s?\\d{4}\\s?\\d{4}\\s?\\d{4}"];
    string owner = 2 [(required) = true];
    google.protobuf.Timestamp issued_at = 3 [(when).in = PAST];
}
```

At build time, Spine Validation injects assertions into the generated Java classes:

```java
var card = CardNumber.newBuilder()
    .setDigits("invalid")
    .build(); <- Validates here.
```

If any constraint is violated, a `ValidationException` is thrown from `build()`.

You can also validate without throwing:

```java
var card = CardNumber.newBuilder()
    .setDigits("invalid")
    .buildPartial(); <- No validation.
var optionalError = card.validate();
error.ifPresent(err -> {
    System.out.println(err.getMessage());
}
```

### Validation Options

The set of validation options is defined by the following files:

1. [spine-base](https://github.com/SpineEventEngine/base) supplies the core validation options with
   the [options.proto](https://github.com/SpineEventEngine/base/blob/master/base/src/main/proto/spine/options.proto).
2. [spine-time](https://github.com/SpineEventEngine/time) supplies time-related options with the
   [time_options.proto](https://github.com/SpineEventEngine/time/blob/master/time/src/main/proto/spine/time_options.proto).

Users should import these Proto files to be able to use options they define.

```protobuf
import "spine/options.proto"; // Brings all options, except for time-related ones.
import "spine/time_options.proto"; // Brings time-related options.
```

## Architecture

The library is a set of plugins for [ProtoData](https://github.com/SpineEventEngine/ProtoData).

Each target language is a separate ProtoData plugin.

Take a look at the following diagram to grasp a high-level library structure:

![High-level library structure overview](.github/readme/high_level_overview.png)

The workflow is the following:

- (1), (2) – user defines Protobuf messages with validation options.
- (3) – Protobuf compiler generates Java classes.
- (4), (5) – policies and views build the validation model.
- (6), (7) – Java plugin generates and injects validation code.

### Key Modules

| Module    | Description                                                          |
|-----------|----------------------------------------------------------------------|
| :model    | The language-agnostic model for the built-in options.                |
| :java     | Generates and injects Java validation code based on applied options. |
| :java-api | Extension API for custom options in Java.                            |

# Extending the Library

Users can extend the library providing custom Protobuf options and code generation logic for them.

Follow these steps to create a custom option:

1. Declare a Protobuf [extension](https://protobuf.dev/programming-guides/proto3/#customoptions)
   in your `.proto` file.
2. Register it via `io.spine.option.OptionsProvider`.
3. Implement the following entities:
   - Policy (`MyOptionPolicy`) – discovers and validates the option.
   - View (`MyOptionView`) – accumulates valid option applications.
   - Generator (`MyOptionGenerator`) – generates Java code for the option.
4. Register them via `io.spine.validation.api.ValidationOption`.

Below is a workflow diagram for a typical option:

![Typical custom option](.github/readme/typical_custom_option.png)

Take a look at the `:java-tests:extensions` module that contains a full example of
implementation of the custom `(currency)` option.

Note that a custom option can provide several policies and views, but only one generator.
This allows building more complex models, using more entities and events.

Let's take a closer look at each entity.

### Policy

Usually, this is an entry point to the option handling. 

The policy subscribes to one of `*OptionDiscovered` events: 

- `FileOptionDiscovered`.
- `MessageOptionDiscovered`.
- `FielddOptionDiscovered`.
- `OneofOptionDiscovered`.

It filters incoming events, taking only those who contain the option of the interest.
The policy may validate the option application, query `TypeSystem`, extract and transform
data arrived with the option, if any. Once ready, it emits an event signaling that the discovered 
option is valid and ready for the code generation.

The policy may report a compilation warning or an error, failing the whole compilation if it
finds an illegal application of the option. 

For example:

1. An unsupported field type.
2. Illegal option content (invalid regex, parameter, signature).

The policy may just ignore the discovered option emitting `NoReaction`. A typical example
of this is a boolean option, such as `(required)`, which does nothing when it is set to `false`.

The desired behavior depends on the option itself.

### View

Views are usually the simplest entities. They just accumulate events from the policies serving 
as data providers of the validation model for code generators.

Usually, one view represents a single application of an option.

Views are not supposed to do something smart, usually they just accumulate data. Use policies 
whenever possible to accommodate your logic.

### Generator

We always have one code generator per option. The generator is asked to provide Java code for all
applications of a specific option within the given message type.

It has access to `Querying` and can query views using a filter to find ones that belong to its
message of interest.

The generator is an entity that provides an actual implementation of the option behavior.

[codecov]: https://codecov.io/gh/SpineEventEngine/validation
[codecov-badge]: https://codecov.io/gh/SpineEventEngine/validation/branch/master/graph/badge.svg
[license-badge]: https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg?style=flat
[license]: http://www.apache.org/licenses/LICENSE-2.0
[gh-actions]: https://github.com/SpineEventEngine/validation/actions
[ubuntu-build-badge]: https://github.com/SpineEventEngine/validation/actions/workflows/build-on-ubuntu.yml/badge.svg
