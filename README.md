[![Ubuntu build][ubuntu-build-badge]][gh-actions]
[![codecov][codecov-badge]][codecov] &nbsp;
[![license][license-badge]][license]

# Spine Validation

This repository contains Spine Validation library.

The library brings data validation into Protobuf messages.

As for now, only the Java target is supported.

### Overview

The library allows declaring validation constraints right in a Protobuf message definition.

An example of the message with several validation constraints:

```protobuf
import "spine/options.proto";
import "spine/time_options.proto";

import "google/protobuf/timestamp.proto";

message CardNumber {

    string digits = 1 [(pattern).regex = "\\d{4}\\s?\\d{4}\\s?\\d{4}\\s?\\d{4}"];
    
    string owner = 2 [(required) = true];
    
    google.protobuf.Timestamp issued_at = 3 [(when).in = PAST];
}
```

Now the generated code of `CardNumber` contains a set of assertions in accordance 
to the used constraints:

```java
if (getOwner().equals("")) {
    // ...
}
if (!getDigits().isEmpty() && !DigitsPattern_en9N85BXqVCE4A.matcher(getDigits()).matches()) {
    // ...
}
if (Timestamps.compare(getIssuedAt(), Time.currentTime()) > 0) {
    // ...
}
```

The generated assertions are invoked upon building an instance of the message:

```java
var card = CardNumber.newBuilder()
    .set...()
    // ...
    .build(); <- Builds and validates the message instance.
```

### Design

The set of supported validation options is defined by the following dependencies:

1. [spine-base](https://github.com/SpineEventEngine/base) defines all validation options
   in the [options.proto](https://github.com/SpineEventEngine/base/blob/master/base/src/main/proto/spine/options.proto)
   file, except for time-related ones.
2. [spine-time](https://github.com/SpineEventEngine/time) defines time-related options
   in [time_options.proto](https://github.com/SpineEventEngine/time/blob/master/time/src/main/proto/spine/time_options.proto).

A user should import these Proto files to be able to use options they define. 

The library is implemented as a plugin for[ProtoData](https://github.com/SpineEventEngine/ProtoData).
Each target language is represented with a separate ProtoData plugin.

Take a look at the following diagram to grasp high-level understanding of how the library works:

![High-level library design overview](.github/readme/high_level_overview.png)

The library workflow is the following:

1. Analyze Proto sources to build a language-agnostic validation model.
2. Use language-specific code generators for the built model.
3. Inject the generated code into the source files generated by `protoc`.

### Key Modules

- `model`: the language-agnostic model of the built-in validation options.
- `proto`: the Protobuf definitions of the `:model`.
- `java`: the Java support of the validation library.
- `java-api`: an extension point to the validation library.

# Extending the library

Users can extend the library providing their custom Protobuf options and logic for their processing.

Below is an overview of steps that should be done to create a custom validation option:

1. Declare a [custom option](https://protobuf.dev/programming-guides/proto3/#customoptions) for Protobuf.
2. Provide an implementation of `io.spine.option.OptionsProvider` that registers the created option
   in `com.google.protobuf.ExtensionRegistry`. This step is required for the Java target.
3. Implement the following entities:
   - `MyOptionPolicy` – validates the option, optionally reporting warnings or compilation errors.
   - `MyOptionView` – accumulates views of the valid option applications.
   - `MyOptionGenerator` – generates Java code for the option.
4. Provide an implementation of `io.spine.validation.api.ValidationOption` that holds
   the created policy, view and generator. Further, `JavaValidationPlugin` will incorporate
   these entities.

A custom option can provide several policies and views, but only one generator.

Policies and views are responsible for building the model of a future option.
Such a model (represented by a view) must contain everything the generator may need
to provide Java code for the option.

Let's look closer at them.

### Policy

Usually, it is an entry point to the option handling. 

The policy subscribes to one of `*OptionDiscovered` events: 

- `FileOptionDiscovered`.
- `MessageOptionDiscovered`.
- `FielddOptionDiscovered`.
- `OneofOptionDiscovered`.

It filters incoming events, taking only those who contain the option of the interest.
The policy may validate the option application, query `TypeSystem`, extract and transform
data arrived with the option. Once ready, it emits an event signaling that the discovered 
option is valid and ready for the code generation.

The policy may report a compilation warning or an error, failing the whole compilation if it
finds an illegal application of the option. For example:

1. Unsupported field type.
2. Illegal option content (invalid regex, parameter, signature).

Also, the policy may just ignore the discovered option emitting `NoReaction`. 

The desired behavior depends on the option itself.

### View

Views are the simplest entities.

They just accumulate events from the policies serving as a storage for the built validation model.

Usually, one view represents a single application of an option.

Views are not supposed to do something smart, usually they just accumulate data. Use policies
as much as possible to accommodate your logic.

### Generator

A `Generator` is the one who actually generates code. 

We always have one generator per option. The generator is asked to provide code for all applications
of a specific option within the given message type.

It has access to `Querying` and can query the view using a filter to find the states of interest.
Then, it goes view-by-view providing code for each option application within the message type.
Further, this code will be injected by the `JavaValidationPlugin`.

# Java Support

This library is built with Java 17.

[codecov]: https://codecov.io/gh/SpineEventEngine/validation
[codecov-badge]: https://codecov.io/gh/SpineEventEngine/validation/branch/master/graph/badge.svg
[license-badge]: https://img.shields.io/badge/license-Apache%20License%202.0-blue.svg?style=flat
[license]: http://www.apache.org/licenses/LICENSE-2.0
[gh-actions]: https://github.com/SpineEventEngine/validation/actions
[ubuntu-build-badge]: https://github.com/SpineEventEngine/validation/actions/workflows/build-on-ubuntu.yml/badge.svg
